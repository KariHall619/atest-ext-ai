name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version:
        description: 'Version/tag to deploy'
        required: true
        default: 'latest'
      force:
        description: 'Force deployment (skip safety checks)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment validation
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      image_exists: ${{ steps.check_image.outputs.exists }}
      version: ${{ steps.parse_version.outputs.version }}
    steps:
    - name: Parse version
      id: parse_version
      run: |
        VERSION="${{ github.event.inputs.version }}"
        if [ "$VERSION" = "latest" ]; then
          VERSION=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest | jq -r '.tag_name' | sed 's/^v//')
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Check Docker image exists
      id: check_image
      run: |
        if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.parse_version.outputs.version }} > /dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Validate deployment
      run: |
        if [ "${{ steps.check_image.outputs.exists }}" != "true" ] && [ "${{ github.event.inputs.force }}" != "true" ]; then
          echo "‚ùå Image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.parse_version.outputs.version }} does not exist"
          exit 1
        fi

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.environment == 'staging'
    environment: staging
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        # Configure kubectl with staging cluster credentials
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Deploy to staging
      run: |
        # Update image tag in Kubernetes manifests
        sed -i 's|atest-ext-ai:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }}|g' k8s/deployment.yaml

        # Apply Kubernetes manifests
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secret.yaml
        kubectl apply -f k8s/rbac.yaml
        kubectl apply -f k8s/pvc.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/hpa.yaml

    - name: Wait for deployment
      run: |
        kubectl rollout status deployment/atest-ai-plugin -n atest-system --timeout=300s
        kubectl rollout status deployment/ollama -n atest-system --timeout=600s

    - name: Run health checks
      run: |
        # Wait for services to be ready
        sleep 30

        # Check if pods are running
        kubectl get pods -n atest-system

        # Check plugin health
        kubectl exec -n atest-system deployment/atest-ai-plugin -- test -S /tmp/atest-store-ai.sock

        # Check Ollama health
        kubectl exec -n atest-system deployment/ollama -- curl -f http://localhost:11434/api/tags

    - name: Run smoke tests
      run: |
        # Add your smoke tests here
        echo "Running smoke tests..."
        # Example: kubectl run test-pod --image=curlimages/curl --rm -it --restart=Never -- curl http://atest-ai-plugin-service:9090/health

  # Deploy to production environment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.environment == 'production'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Production deployment confirmation
      run: |
        echo "üöÄ Deploying version ${{ needs.validate.outputs.version }} to PRODUCTION"
        echo "This action will affect the production environment!"

    - name: Configure kubectl
      run: |
        # Configure kubectl with production cluster credentials
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Create backup
      run: |
        # Create backup of current deployment
        kubectl get deployment atest-ai-plugin -n atest-system -o yaml > backup-deployment-$(date +%Y%m%d-%H%M%S).yaml

    - name: Deploy to production
      run: |
        # Update image tag in Kubernetes manifests
        sed -i 's|atest-ext-ai:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }}|g' k8s/deployment.yaml

        # Apply production-specific configurations
        sed -i 's|replicas: 2|replicas: 5|g' k8s/deployment.yaml  # Scale up for production
        sed -i 's|log_level: info|log_level: warn|g' k8s/configmap.yaml  # Reduce log verbosity

        # Apply Kubernetes manifests
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secret.yaml
        kubectl apply -f k8s/rbac.yaml
        kubectl apply -f k8s/pvc.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/hpa.yaml
        kubectl apply -f k8s/ingress.yaml

    - name: Rolling deployment
      run: |
        # Perform rolling update
        kubectl set image deployment/atest-ai-plugin atest-ai-plugin=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }} -n atest-system
        kubectl rollout status deployment/atest-ai-plugin -n atest-system --timeout=600s

    - name: Production health checks
      run: |
        # Wait for services to be ready
        sleep 60

        # Comprehensive health checks
        kubectl get pods -n atest-system
        kubectl top pods -n atest-system

        # Check all replicas are ready
        READY_REPLICAS=$(kubectl get deployment atest-ai-plugin -n atest-system -o jsonpath='{.status.readyReplicas}')
        DESIRED_REPLICAS=$(kubectl get deployment atest-ai-plugin -n atest-system -o jsonpath='{.spec.replicas}')

        if [ "$READY_REPLICAS" != "$DESIRED_REPLICAS" ]; then
          echo "‚ùå Not all replicas are ready: $READY_REPLICAS/$DESIRED_REPLICAS"
          exit 1
        fi

    - name: Production smoke tests
      run: |
        echo "Running production smoke tests..."
        # Add comprehensive production tests here

    - name: Rollback on failure
      if: failure()
      run: |
        echo "‚ùå Deployment failed, initiating rollback..."
        kubectl rollout undo deployment/atest-ai-plugin -n atest-system
        kubectl rollout status deployment/atest-ai-plugin -n atest-system --timeout=300s

  # Post-deployment monitoring
  monitor:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
    - name: Monitor deployment
      run: |
        echo "üîç Monitoring deployment for 5 minutes..."
        # Add monitoring scripts here
        # Check metrics, logs, alerts, etc.

    - name: Generate deployment report
      run: |
        echo "üìä Deployment Report"
        echo "Environment: ${{ github.event.inputs.environment }}"
        echo "Version: ${{ needs.validate.outputs.version }}"
        echo "Status: ${{ needs.deploy-staging.result || needs.deploy-production.result }}"
        echo "Timestamp: $(date -u)"

  # Notify deployment result
  notify:
    name: Notify Deployment Result
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging, deploy-production, monitor]
    if: always()
    steps:
    - name: Notify success
      if: (needs.deploy-staging.result == 'success' && github.event.inputs.environment == 'staging') || (needs.deploy-production.result == 'success' && github.event.inputs.environment == 'production')
      run: |
        echo "‚úÖ Successful deployment to ${{ github.event.inputs.environment }}"
        echo "Version: ${{ needs.validate.outputs.version }}"
        # Add notification to team communication tools

    - name: Notify failure
      if: (needs.deploy-staging.result == 'failure' && github.event.inputs.environment == 'staging') || (needs.deploy-production.result == 'failure' && github.event.inputs.environment == 'production')
      run: |
        echo "‚ùå Failed deployment to ${{ github.event.inputs.environment }}"
        echo "Version: ${{ needs.validate.outputs.version }}"
        # Add failure notification to team communication tools